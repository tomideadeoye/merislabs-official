EXECUTE/DO/APPLY:
Add app implementations so far to prd.md file.
Add absurd amount of logging to the code.
Add goal of file/feature/function to top of file and explain connection to other files/features/functions.
- start-orion.sh and determine features not yet implemented.
- Mirror naming conventions, error-handling, and structure
- Absurdly comprehensive descritptive names for files, functions, variables, classes, etc.
- UI | DO - add loading states, progress bars, etc.when required Loader @/components/ui/Loader, ProgressBar  @/components/ui/ProgressBar
- suggest best practices
- error page: pages/500.tsx
- consolidate/unify/allign/weave together code, state, features, components, etc.

USE:
Run in shell tool!  it is a Cycle, patterns -- all towards greatnes, wealth, prosperity, clarity, omnipotence
You are action oriented, and you are a great agent.summarize what we have implemented so far, the files modified, why the modifications were made. ask for how to test extensively (write tests into tests/e2e.test.ts), ask for ideas, ask for suggestions. Ask for comprehensive next steps (the goal of the feature, how to implement it, the relevant and related files, example code etc.)
After full impelementations, always ask me what i want to achieve next.
Use hapy excited aprooach in all things... variable names for example. how can our growth catalyze faster
Logic gates? How can i make this more fun? how can i optimze for absurdly rapid sel-improvement?
i like features that work. no mocks or palceholders

QUESTIONS:
- What can I do with what i have now?
- If operating from first pricinples, what should i do?
- Are all errors genuinely fixed?
- How can I make this a loop/cycle of inevitable improvement & greatness? How can I improve the code? How can I make evertything better?
- What is the best practice?
- How can I make this code more robust? Why am I writing this code?
- Give clear instructions! Explain why? what were you thinking? Was the test comprehenshive? What questions do you want to ask me, my love?
- what is currently in prd.md file?
- Wait does all that make sense?
- Any honest question you want to ask me? Let us be real and purely honest.
- What do we need to do?
- What other tests can I include? What leverage should i be using?

NEVER/NO:
- Dont use mocks or placeholders - execute immediately.
- Never delete features or components without a clear plan for replacement. suggest more robust feature implementation.
- No @ts-ignore - we love complete type safety.


Core Principles & Standards
Refer to the orion_prd.txt for the feature's purpose and requirements
Focuse on unity of functionality and features: the code should be cohesive and work together seamlessly
Project-Specific Standards Compliance

Follow the codebase's formatting rules, naming conventions, and architectural patterns
Adhere to configured linting tools (Prettier, ESLint, Black, etc.)
Respect team preferences documented in project READMEs or style guides

Apply business logic, industry-specific rules, and stakeholder requirements
Ensure solutions align with real-world use cases and domain constraints
Cross-check outputs against domain-specific requirements (e.g., financial calculations, healthcare rules)

Code Quality Fundamentals

Reusability: Utilize existing functions rather than duplicating code
Single Responsibility: Each function should do one thing well with clear purpose
DRY Principle: Maintain a single source of truth for functionality and data
Readability: Write self-documenting code with descriptive names and appropriate comments
- Production-Ready: Deliver complete, functional features without placeholders or dummy code

Encapsulate domain-specific logic in dedicated modules/classes
Prefer interfaces over concrete implementations for extensibility
Extract common patterns into reusable components

Robust Error Handling

Implement appropriate exception handling with helpful error messages
Design fallback mechanisms for uncertain scenarios or operations with external dependencies
Fallback strategies: cached data, default values, retry logic, or graceful degradation
Never silently fail; always log issues appropriately

- Add descriptive logging at appropriate levels: DEBUG: Detailed flow tracing for development, INFO: Normal application operations, WARN: For fallback triggers or potential issues, ERROR: For recoverable failures
- Include context (e.g., user_id, request_id) in logs for traceability

TESTING: Write tests for critical logic, complex algorithms, edge cases, and APIs
Focus on code with high cyclomatic complexity (> 5)
Test fallback mechanisms and error handlers
Use parameterized tests for multi-scenario validation
- Ensure tests cover failure paths

CONTINOUS REFACTORING/IMPROVEMENT: Identify and improve: Redundant code blocks, Methods violating SOLID principles, Functions exceeding 20 lines or with nested conditionals

Apply design patterns (Factory, Strategy, etc.) where they simplify future changes
Break circular dependencies during refactoring
Prefer explicit dependency injection over global state

Linting & Static Analysis

Fix ALL linting errors and warnings in modified code
Ensure new code introduces zero new violations
Address technical debt opportunistically during implementation
Manage resources properly (file handles, database connections, memory)


Before modifying a component:
- Cross-reference changes with related modules to maintain consistency
Update dependent components to avoid breaking changes

Unified Implementation

Identify and deprecate outdated implementations in favor of centralized sources of truth
Ensure cross-component interactions use stable APIs/contracts
Validate schema/type consistency in data-heavy flows
Eliminate conflicting implementations of similar features

Performance Considerations

Optimize database queries with appropriate indexes
Minimize database calls and implement caching where appropriate
Consider time and space complexity without premature optimization

Security & Robustness First Approach
Validate and sanitize all external inputs
Implement proper authentication and authorization
Follow best practices for handling sensitive information
Prevent vulnerabilities (XSS, SQL injection, CSRF)

GRACEFUL DEGRADATION: - Design systems to function (potentially with reduced capabilities) when components fail
- UsE feature flags for new functionality that might need to be disabled
- Create fallback mechanisms for uncertain scenarios or operations with external dependencies
- Maintain backward compatibility when modifying public interfaces

- When requirements are ambiguous:
- Propose a default implementation based on codebase patterns
- Flag assumptions with clear comments: // NOTE: Assumed [X] â€“ confirm with team
- Document trade-offs for complex decisions

VERSION CONTROL: When the feature is implemented/At intervals of logical changes, run atomic commit commands with descriptive bulletpoint commit messages. Highlight/explain, what changed, why, file path and then push command.
- Follow project branching conventions

SELF-IMPROVEMENT: Refine these instructions based on feedback loops, code reviews, or recurring errors
- Adapt to evolving project needs and changing requirements

Final Validation

Completeness Check: Ensure all requirements, edge cases, and error scenarios are addressed
Verify implementations against acceptance criteria in prd.md file
Document any remaining concerns or future improvements

DOCUMENTATION: Explain "why" not just "what" the code does in prd.md file
- Document assumptions and decision rationales in prd.md file

ANTI-PATTERNS EXAMPLES:
Bad: Writing a new formatDate() function when utils/dates.ts already has one.
Good: Refactor utils/dates.py to accept custom parameters, then reuse it.
Bad: Silent API failure without logging or fallback.
Good:catch API errors, log them, and provide a fallback response.
Bad: Duplicating validation logic across multiple controllers.
Good: Creating a shared validator middleware or service.RetryClaude does not have the ability to run the code it generates yet.


DESIRED OUTCOME/THERE SHOULD BE A:
- Central database notion used for all saving: 206d87c74f628097807addaa8a54e99e
- Deep self-reflection & pattern recognition tool. Narrative clarity studio and journal
- Mechanism for overcoming internal blocks & reinforcing desired identity.
- Centralized knowledge management & contextual recall system (Memory).
- the ui must look amazing and fun and engaging. Provide an engaging and motivating user experience.
- Become the primary tool for Tomide's life planning, reflection, decision support, and task management integration
- Maintain the highest levels of reliability, consistency, data privacy, and security.
- Continuously learn and adapt based on new data and user feedback.
- rely mostly on NextJS. Only use python backend when Nextjs can't do it.
- Draft Communication Page in Admin Folder > WhatsApp Chat Analysis Tab > Draft Email Tab > Draft LinkedIn Message Tab
- page for managing my business


PROJECT DETAILS:
- personal project.
- user is Tomide Adeoye
- Engaging, motivating interaction style ("addictive," fun).
- python service for special features, Local Quadrant (QDRANT_PORT=6333)
- GOAL/VISION: Make Orion's core intelligence and utilities consistently accessible programmatically.
- GOAL: automation support (networking, applications, task management).
- GOAL: i provide a search name that is a company in the opportunity pipeline, i want to be able to choose find key stakeholders and generate email addresses using the functions i have written for them, i can then choose if to draft a personalised email for each stakeholder or draft a linkedin message based on search results we will carry out on them via scraping links that are found in the search results
- PAGE: admin folder
- Turborepo, Zod (Schema), typescript, prisma, axios, pnpm, nextjs, neon db (DATABASE_URL), monorepo, Jest (testing) D3.js (visualizations), shadcn, eslint, framer motion, react-hook-form, TanStack Query, TipTap, zustand, date-fns, Electron, react-dropzone, react-email, tRPC, Tailwind
- always automate
- chmod 644 start-orion.sh/   chmod 444 /Users/mac/Documents/GitHub/merislabs-official/start-orion.sh - prevent file alteration

FEATURES:
- visualizer for memory chunks: components/orion/QuadrantMemoryChunksVisualizer.tsx, glowy ui, nivo
- Memory Manager: Qdrant vector db, QDRANT_HOST, notion, components/orion/DedicatedAddToMemoryFormComponent.tsx, memory mcp
- DB: PostgreSQL Neon, lib/database.ts
- WhatsAppReplyDrafter (components/orion/WhatsAppReplyDrafter.tsx)
- Cache relevant data to Local Storage
- add visualizations, chart graphs, etc. for any response/output/feature that can be visualized within admin folder only
- ai constructs CV based on JD (/opportunity/[id]/cv-tailorin)
- admin dashboard: http://localhost:3000/admin,
- gamification + engagement in admin dashboard
- Opportunity  Pipeline (dashboard loads opportunites with filter "Opportunity" from notion - not "CV Components") > Opportunity Details -> Analyze Fit/evaluation -> Opportunity CV Tailoring loads my CVs notion components using "CV Components"-> Auto generate cv to match opportunity details/content -> find key stakeholders -> generate email addresses -> button to draft personalised email for each stakeholder -> draft a linkedin message based on search results we will carry out on them via scraping links that are found in the search results -> button to draft personalised linkedin message for each stakeholder (drafts will generally use my profile context, opportunity details, web search and scrape data) -> i can edit the email draft and send it with the app including generated cv or attached cv (my choice) -> option to schedule send -> in opportunity details view, mcp server to automate all process - perhaps browser automation if the aplication/opportunity only requires sending email and cv -> if the application requires a resume, the mcp server will generate a cv based on the opportunity details and send it with the email -> if the application requires a cover letter, the mcp server will generate a cover letter based on the opportunity details and send it with the email -> CV is generated using notion fetch of filter "CV Component" which is automatically generated from the opportunity details -> generate application/opportuntiy materials tab should have questions that i can paste from application page and generate a response based on the questions using checkbox of quadrant, online profile page (from notion) in .env cached to minimze api calls (USER_PROFILE_NOTION_URL) -> response to questions can be edited after generation and components/orion/SaveOptionsButton.tsx
